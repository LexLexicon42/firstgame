# Rigamortus: Text-Based Historical Adventure Game

## Overview
"Rigamortus" is a text-based historical adventure game created using Python. The game aims to immerse players in historical scenarios, allowing them to make decisions that shape their path. Inspired by classic text-based adventure games like Zork and modern titles like Detroit Become Human, "Rigamortus" combines historical accuracy with engaging gameplay mechanics.

## Key Features
- **Historical Immersion:** Players navigate historical settings, facing fickle choices that impact their journey.
- **Decision Making:** Choices made by the player influence the storyline and outcome, creating a dynamic narrative experience.
- **Complex Gameplay Mechanics:** Utilizes object-oriented programming, exception handling, and complex data structures to manage user interactions, save/load systems, and character interactions.
- **Mini-games:** Engaging mini-games implemented using the Pygame library to maintain player engagement.

## Programming Language and Libraries
- **Python:** Chosen for its ease of use, extensive library support, and robust debugging capabilities.
- **Libraries Used:** Pygame for mini-game development, os for system operations, re for data validation, json for data parsing, and hashlib for password encryption.

## Base Mechanics and Layout
- Text-based input system designed for orderly progression through the game.
- Class-based structure for efficient data management and code organization.

## Mini-games
- Utilizes Pygame library to create engaging mini-games within the game.
- Mathematical models and flowcharts used to simulate game mechanics such as timing and collision systems.

## Classes Design
- Property decorators (@) used for efficient attribute management.
- Implementation of composition, aggregation, and inheritance for robust object-oriented design.

## Combat System
- Classes Allies, Hitler, and Team designed for final boss battle mechanics.
- Decision-making methods and combat mechanics simulated through class interactions.

## Final Maze Algorithm
- Algorithmic approach to maze generation and traversal for engaging gameplay.
- Use of CSV files and Pygame for maze rendering and interaction.

## How to Play
1. **Installation:** Clone the repository and ensure Python and necessary libraries are installed.
2. **Run the Game:** Execute the main game file to start playing.
3. **Navigate:** Use text inputs to progress through the storyline and make choices.
4. **Engage in Mini-games:** Encounter mini-games throughout the game and follow on-screen instructions to play.
5. **Reach the End:** Navigate through historical scenarios, solve puzzles, and reach the final boss battle to complete the game.

## Contributions
Contributions to the game codebase are welcome through pull requests. Refer to the contribution guidelines in the repository for more information.

